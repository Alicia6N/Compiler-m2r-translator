class prfcorrecto2 {

attributes:

 int laberinto[5][5];

methods:

 int inicializarLaberinto(int n)
 {
  int i,j;

  // rellenar con 0s el laberinto
  i=0;
  while (i<n)
  {
    j=0;
    while (j<n)
    {
      laberinto[i][j] = 0;
      j=j+1;
    }
    i=i+1;
  }
  return 1;
 }

 int ponerCaminos(int n)
 {
  int i,j;

  // poner dos caminos: diagonal y abajo+derecha
  i=0;
  while (i<n)
  {
    laberinto[i][i] = 1;
    i=i+1;
  }

  i=0;
  while (i<n)
  {
    laberinto[i][0] = 1;
    i=i+1;
  }  
  
  i=1;
  while (i<n)
  {
    laberinto[n-1][i] = 1;
    i=i+1;
  }
  return 1; 
 }

 int buscarCamino(int n)
 {
  int i,j;
  int lon,error,salir;

  // buscar camino  (voraz)
  lon=1;
  error=0;
  salir=0;
  i=0;
  j=0;
  print(i);
  print(j);
  //while (i<n && j<n && error==0 && salir==0)
  while ((i<n) * (j<n) * (error==0) * (salir==0))
  {
    if (laberinto[i][j])
    {
      int mov; mov=0;
      // if ((i<n-1) * (j<n-1) * laberinto[i+1][j+1])  // casca por que no es && y no hay evaluaciÃ³n en cortocircuito
      if ((i<n-1) * (j<n-1))
      {
        if (laberinto[i+1][j+1])
        {
         i=i+1;
         j=j+1;
         lon=lon+1;
         mov=1;
        }
      }
      if ((mov==0) * (i<n-1))
        if (laberinto[i+1][j])
        {
         i=i+1;
         lon=lon+1;
         mov=1;
        }
      if ((mov==0) * (j<n-1))
        if (laberinto[i][j+1])
        {
         j=j+1;
         lon=lon+1;
         mov=1;
        }
      if (mov==1) 
      {
        print(i);
        print(j);
      }
      else 
      {
        if ((i<n-1) + (j<n-1)) // si no hemos llegado al final
          error=1;
        else
          salir=2;
      }
    }
  }
  
  if (error) lon=0-1;
  
  return lon;
 }

 int main()
 {
  int i,j;
  int lon,error;
  
  if (inicializarLaberinto(5) * ponerCaminos(5))
  {
    lon = buscarCamino(5);
    print(lon); // debe salir 5

  
    // capamos la diagonal, y repetimos
    laberinto[1][1]=0;
    lon = buscarCamino(5);
    print(lon); // debe salir 8
    
  }
 }
}
