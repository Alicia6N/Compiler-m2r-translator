; Array i empieza en = @B+0
; Array i empieza en = @B+0
; Array j empieza en = @B+1
; Array j empieza en = @B+1
; Array this.p empieza en = 3
; Array i empieza en = @B+0
; Array j empieza en = @B+1
; Array j empieza en = @B+1
; Array j empieza en = @B+1
; Array i empieza en = @B+0
; Array i empieza en = @B+0
; Array j empieza en = @B+1
; Array j empieza en = @B+1
; Array i empieza en = @B+0
; Array i empieza en = @B+0
; Array this.p empieza en = 3
; Array j empieza en = @B+1
; Array i empieza en = @B+0
; Array this.p empieza en = 3
; Array j empieza en = @B+1
; Array i empieza en = @B+0
; Array j empieza en = @B+1
; Array i empieza en = @B+0
; Array this.p empieza en = 3
; Array j empieza en = @B+1
; Array i empieza en = @B+0
; Array i empieza en = @B+0
; Array i empieza en = @B+0
; Array j empieza en = @B+1
; Array j empieza en = @B+1
; Array i empieza en = @B+0
; Array i empieza en = @B+0
; Array j empieza en = @B+1
; Array j empieza en = @B+1
; Array this.p empieza en = 3
; Array i empieza en = @B+0
; Array j empieza en = @B+1
; Array j empieza en = @B+1
; Array j empieza en = @B+1
; Array i empieza en = @B+0
; Array i empieza en = @B+0
mov #19 B
jmp L1

L1  mov #0 @B+3		; guarda entero 0
mov @B+3 @B+0		; i = @B+3; 
L4 mov @B+0 @B+4		; guarda id i
mov #4 @B+5		; guarda entero 4
mov @B+4 A
lssi @B+5	; Expr relop Esimple
mov A @B+6	; guardar el resultado en temporal
	; WHILE
mov @B+6 A
jz L5	 ; if else
 mov #0 @B+7		; guarda entero 0
mov @B+7 @B+1		; j = @B+7; 
L2 mov @B+1 @B+8		; guarda id j
mov #4 @B+9		; guarda entero 4
mov @B+8 A
lssi @B+9	; Expr relop Esimple
mov A @B+10	; guardar el resultado en temporal
	; WHILE
mov @B+10 A
jz L3	 ; if else
 mov #0 @B+11	; guarda 0 y empieza recursivo arrays de en 'Ref id' this.p
mov @B+0 @B+12		; guarda id i
mov @B+11 A 	; hace recursivo de arrays en Ref
muli #4
addi @B+12 
mov A @B+13 
mov @B+1 @B+14		; guarda id j
mov @B+13 A 	; hace recursivo de arrays en Ref
muli #4
addi @B+14 
mov A @B+15 

;scan
mov @B+15 A
muli #1 
addi #3
rdi @B+16	; guardar valor entero en temporal
mov @B+16 @A

mov @B+1 @B+17		; guarda id j
mov #1 @B+18		; guarda entero 1
mov @B+17 A
addi @B+18	; ENTERO + ENTERO
mov A @B+19	; guardar el resultado en temporal
mov @B+19 @B+1		; j = @B+19; 
jmp L2
	; ENDWHILE
L3 mov @B+0 @B+20		; guarda id i
mov #1 @B+21		; guarda entero 1
mov @B+20 A
addi @B+21	; ENTERO + ENTERO
mov A @B+22	; guardar el resultado en temporal
mov @B+22 @B+0		; i = @B+22; 
jmp L4
	; ENDWHILE
L5 mov #0 @B+23		; guarda entero 0
mov @B+23 @B+1		; j = @B+23; 
L8 mov @B+1 @B+24		; guarda id j
mov #4 @B+25		; guarda entero 4
mov @B+24 A
lssi @B+25	; Expr relop Esimple
mov A @B+26	; guardar el resultado en temporal
	; WHILE
mov @B+26 A
jz L9	 ; if else
 mov #0 @B+27		; guarda entero 0
mov @B+27 @B+0		; i = @B+27; 
L6 mov @B+0 @B+28		; guarda id i
mov #4 @B+29		; guarda entero 4
mov @B+28 A
lssi @B+29	; Expr relop Esimple
mov A @B+30	; guardar el resultado en temporal
	; WHILE
mov @B+30 A
jz L7	 ; if else
 
;print
mov #0 @B+31	; guarda 0 y empieza recursivo arrays de en 'Ref id' this.p
mov @B+1 @B+32		; guarda id j
mov @B+31 A 	; hace recursivo de arrays en Ref
muli #4
addi @B+32 
mov A @B+33 
mov @B+0 @B+34		; guarda id i
mov @B+33 A 	; hace recursivo de arrays en Ref
muli #4
addi @B+34 
mov A @B+35 
mov #0 @B+35		; guarda 0 y empieza en Factor recursivo arrays de this.p
mov @B+35 @B+36		; guarda id this.p
muli #1 
addi #3
mov @A @B+36	;acaba array en Factor
wri @B+36	; print valor entero de temporal
wrl
mov #0 @B+37	; guarda 0 y empieza recursivo arrays de en 'Ref id' this.p
mov @B+1 @B+38		; guarda id j
mov @B+37 A 	; hace recursivo de arrays en Ref
muli #4
addi @B+38 
mov A @B+39 
mov @B+0 @B+40		; guarda id i
mov @B+39 A 	; hace recursivo de arrays en Ref
muli #4
addi @B+40 
mov A @B+41 
mov @B+1 @B+42		; guarda id j
mov #4 @B+43		; guarda entero 4
mov @B+42 A
muli @B+43	; ENTERO * ENTERO
mov A @B+44
mov @B+0 @B+45		; guarda id i
mov @B+44 A
addi @B+45	; ENTERO + ENTERO
mov A @B+46	; guardar el resultado en temporal
mov @B+41 A	; empieza arrays en Ref asig de: this.p
muli #1 
addi #3
mov @B+46 @A	; acaba arrays en Ref asig

;print
mov #0 @B+47	; guarda 0 y empieza recursivo arrays de en 'Ref id' this.p
mov @B+1 @B+48		; guarda id j
mov @B+47 A 	; hace recursivo de arrays en Ref
muli #4
addi @B+48 
mov A @B+49 
mov @B+0 @B+50		; guarda id i
mov @B+49 A 	; hace recursivo de arrays en Ref
muli #4
addi @B+50 
mov A @B+51 
mov #0 @B+51		; guarda 0 y empieza en Factor recursivo arrays de this.p
mov @B+51 @B+52		; guarda id this.p
muli #1 
addi #3
mov @A @B+52	;acaba array en Factor
wri @B+52	; print valor entero de temporal
wrl
mov @B+0 @B+53		; guarda id i
mov #1 @B+54		; guarda entero 1
mov @B+53 A
addi @B+54	; ENTERO + ENTERO
mov A @B+55	; guardar el resultado en temporal
mov @B+55 @B+0		; i = @B+55; 
jmp L6
	; ENDWHILE
L7 mov @B+1 @B+56		; guarda id j
mov #1 @B+57		; guarda entero 1
mov @B+56 A
addi @B+57	; ENTERO + ENTERO
mov A @B+58	; guardar el resultado en temporal
mov @B+58 @B+1		; j = @B+58; 
jmp L8
	; ENDWHILE
L9 mov #0 @B+59		; guarda entero 0
mov @B+59 @B+0		; i = @B+59; 
L12 mov @B+0 @B+60		; guarda id i
mov #4 @B+61		; guarda entero 4
mov @B+60 A
lssi @B+61	; Expr relop Esimple
mov A @B+62	; guardar el resultado en temporal
	; WHILE
mov @B+62 A
jz L13	 ; if else
 mov #0 @B+63		; guarda entero 0
mov @B+63 @B+1		; j = @B+63; 
L10 mov @B+1 @B+64		; guarda id j
mov #4 @B+65		; guarda entero 4
mov @B+64 A
lssi @B+65	; Expr relop Esimple
mov A @B+66	; guardar el resultado en temporal
	; WHILE
mov @B+66 A
jz L11	 ; if else
 
;print
mov #0 @B+67	; guarda 0 y empieza recursivo arrays de en 'Ref id' this.p
mov @B+0 @B+68		; guarda id i
mov @B+67 A 	; hace recursivo de arrays en Ref
muli #4
addi @B+68 
mov A @B+69 
mov @B+1 @B+70		; guarda id j
mov @B+69 A 	; hace recursivo de arrays en Ref
muli #4
addi @B+70 
mov A @B+71 
mov #0 @B+71		; guarda 0 y empieza en Factor recursivo arrays de this.p
mov @B+71 @B+72		; guarda id this.p
muli #1 
addi #3
mov @A @B+72	;acaba array en Factor
wri @B+72	; print valor entero de temporal
wrl
mov @B+1 @B+73		; guarda id j
mov #1 @B+74		; guarda entero 1
mov @B+73 A
addi @B+74	; ENTERO + ENTERO
mov A @B+75	; guardar el resultado en temporal
mov @B+75 @B+1		; j = @B+75; 
jmp L10
	; ENDWHILE
L11 mov @B+0 @B+76		; guarda id i
mov #1 @B+77		; guarda entero 1
mov @B+76 A
addi @B+77	; ENTERO + ENTERO
mov A @B+78	; guardar el resultado en temporal
mov @B+78 @B+0		; i = @B+78; 
jmp L12
	; ENDWHILE
L13 halt
