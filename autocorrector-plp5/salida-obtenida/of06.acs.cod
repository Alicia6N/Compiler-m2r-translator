; Array this.a empieza en = 113
; Array this.a empieza en = 113
; Array this.a empieza en = 113
; Array this.a empieza en = 113
; Array this.a empieza en = 113
; Array size empieza en = @B+2
;Guarda desde: 3
;Actual empieza: 6
;Hasta: 6
; Array i empieza en = @B+0
; Array i empieza en = @B+0
; Array size empieza en = @B+2
; Array j empieza en = @B+1
; Array i empieza en = @B+0
; Array j empieza en = @B+1
; Array size empieza en = @B+2
; Array this.a empieza en = 113
; Array i empieza en = @B+0
; Array this.a empieza en = 113
; Array j empieza en = @B+1
; Array tmp empieza en = @B+25
; Array this.a empieza en = 113
; Array i empieza en = @B+0
; Array this.a empieza en = 113
; Array i empieza en = @B+0
; Array this.a empieza en = 113
; Array j empieza en = @B+1
; Array this.a empieza en = 113
; Array j empieza en = @B+1
; Array tmp empieza en = @B+25
; Array j empieza en = @B+1
; Array j empieza en = @B+1
; Array i empieza en = @B+0
; Array i empieza en = @B+0
; Array i empieza en = @B+0
; Array j empieza en = @B+1
; Array i empieza en = @B+0
; Array i empieza en = @B+0
; Array this.a empieza en = 113
; Array i empieza en = @B+0
; Array i empieza en = @B+0
; Array i empieza en = @B+0
; Array i empieza en = @B+0
; Array foo empieza en = @B+0
;Guarda desde: 1
;Actual empieza: 4
;Hasta: 4
; Array foo empieza en = @B+0
;Guarda desde: 4
;Actual empieza: 7
;Hasta: 7
; Array foo empieza en = @B+0
;Guarda desde: 7
;Actual empieza: 10
;Hasta: 10
; Array foo empieza en = @B+0
;Guarda desde: 10
;Actual empieza: 13
;Hasta: 13
mov #118 B
jmp L12

; metodo: 'initialization'
L1 mov #0 @B+1	; guarda 0 y empieza recursivo arrays de en 'Ref id' this.a
mov #0 @B+2		; guarda entero 0
mov @B+1 A 	; hace recursivo de arrays en Ref
muli #5
addi @B+2	; fallo en este 
mov A @B+3 
mov #5 @B+4		; guarda entero 5
mov @B+3 A	; empieza arrays en Ref asig de: this.a
muli #1 
addi #113
mov @B+4 @A	; acaba arrays en Ref asig
mov #0 @B+5	; guarda 0 y empieza recursivo arrays de en 'Ref id' this.a
mov #1 @B+6		; guarda entero 1
mov @B+5 A 	; hace recursivo de arrays en Ref
muli #5
addi @B+6	; fallo en este 
mov A @B+7 
mov #4 @B+8		; guarda entero 4
mov @B+7 A	; empieza arrays en Ref asig de: this.a
muli #1 
addi #113
mov @B+8 @A	; acaba arrays en Ref asig
mov #0 @B+9	; guarda 0 y empieza recursivo arrays de en 'Ref id' this.a
mov #2 @B+10		; guarda entero 2
mov @B+9 A 	; hace recursivo de arrays en Ref
muli #5
addi @B+10	; fallo en este 
mov A @B+11 
mov #3 @B+12		; guarda entero 3
mov @B+11 A	; empieza arrays en Ref asig de: this.a
muli #1 
addi #113
mov @B+12 @A	; acaba arrays en Ref asig
mov #0 @B+13	; guarda 0 y empieza recursivo arrays de en 'Ref id' this.a
mov #3 @B+14		; guarda entero 3
mov @B+13 A 	; hace recursivo de arrays en Ref
muli #5
addi @B+14	; fallo en este 
mov A @B+15 
mov #2 @B+16		; guarda entero 2
mov @B+15 A	; empieza arrays en Ref asig de: this.a
muli #1 
addi #113
mov @B+16 @A	; acaba arrays en Ref asig
mov #0 @B+17	; guarda 0 y empieza recursivo arrays de en 'Ref id' this.a
mov #4 @B+18		; guarda entero 4
mov @B+17 A 	; hace recursivo de arrays en Ref
muli #5
addi @B+18	; fallo en este 
mov A @B+19 
mov #1 @B+20		; guarda entero 1
mov @B+19 A	; empieza arrays en Ref asig de: this.a
muli #1 
addi #113
mov @B+20 @A	; acaba arrays en Ref asig
mov #5 @B+21		; guarda entero 5
; Secuencia de retorno
mov @B+21 @B-3
mov @B-2 A
jmp @A
; DIR USED = 22
mov #0 @B-3
mov @B-2 A
jmp @A

; metodo: 'sort'
L2 ; Secuencia de llamada
mov B @B+6
mov B A
addi #7
mov A B
mvetq L3 @B-2
jmp L1
L3 mov @B-1 B
mov @B+4 @B+2		; size = @B+4; 
mov #0 @B+7		; guarda entero 0
mov @B+7 @B+0		; i = @B+7; 
L7 mov @B+0 @B+8		; guarda id i
mov @B+2 @B+9		; guarda id size
mov @B+8 A
lssi @B+9	; Expr relop Esimple
mov A @B+10	; guardar el resultado en temporal
	; WHILE
mov @B+10 A
jz L8	 ; if else
 mov @B+0 @B+11		; guarda id i
mov #1 @B+12		; guarda entero 1
mov @B+11 A
addi @B+12	; ENTERO + ENTERO
mov A @B+13	; guardar el resultado en temporal
mov @B+13 @B+1		; j = @B+13; 
L5 mov @B+1 @B+14		; guarda id j
mov @B+2 @B+15		; guarda id size
mov @B+14 A
lssi @B+15	; Expr relop Esimple
mov A @B+16	; guardar el resultado en temporal
	; WHILE
mov @B+16 A
jz L6	 ; if else
 mov #0 @B+17	; guarda 0 y empieza recursivo arrays de 'Ref this' this.a
mov @B+0 @B+18		; guarda id i
mov @B+17 A 	; hace recursivo de arrays en Ref
muli #5
addi @B+18	; fallo en este 
mov A @B+19 
mov #0 @B+19		; guarda 0 y empieza en Factor recursivo arrays de this.a
mov @B+19 @B+20		; guarda id this.a
muli #1 
addi #113
mov @A @B+20	;acaba array en Factor
mov #0 @B+21	; guarda 0 y empieza recursivo arrays de en 'Ref id' this.a
mov @B+1 @B+22		; guarda id j
mov @B+21 A 	; hace recursivo de arrays en Ref
muli #5
addi @B+22	; fallo en este 
mov A @B+23 
mov #0 @B+23		; guarda 0 y empieza en Factor recursivo arrays de this.a
mov @B+23 @B+24		; guarda id this.a
muli #1 
addi #113
mov @A @B+24	;acaba array en Factor
mov @B+20 A
gtri @B+24	; Expr relop Esimple
mov A @B+25	; guardar el resultado en temporal
mov @B+25 A
jz L4 	 ; if 
 mov #0 @B+27	; guarda 0 y empieza recursivo arrays de 'Ref this' this.a
mov @B+0 @B+28		; guarda id i
mov @B+27 A 	; hace recursivo de arrays en Ref
muli #5
addi @B+28	; fallo en este 
mov A @B+29 
mov #0 @B+29		; guarda 0 y empieza en Factor recursivo arrays de this.a
mov @B+29 @B+30		; guarda id this.a
muli #1 
addi #113
mov @A @B+30	;acaba array en Factor
mov @B+30 @B+25		; tmp = @B+30; 
mov #0 @B+31	; guarda 0 y empieza recursivo arrays de en 'Ref id' this.a
mov @B+0 @B+32		; guarda id i
mov @B+31 A 	; hace recursivo de arrays en Ref
muli #5
addi @B+32	; fallo en este 
mov A @B+33 
mov #0 @B+34	; guarda 0 y empieza recursivo arrays de 'Ref this' this.a
mov @B+1 @B+35		; guarda id j
mov @B+34 A 	; hace recursivo de arrays en Ref
muli #5
addi @B+35	; fallo en este 
mov A @B+36 
mov #0 @B+36		; guarda 0 y empieza en Factor recursivo arrays de this.a
mov @B+36 @B+37		; guarda id this.a
muli #1 
addi #113
mov @A @B+37	;acaba array en Factor
mov @B+33 A	; empieza arrays en Ref asig de: this.a
muli #1 
addi #113
mov @B+37 @A	; acaba arrays en Ref asig
mov #0 @B+38	; guarda 0 y empieza recursivo arrays de 'Ref this' this.a
mov @B+1 @B+39		; guarda id j
mov @B+38 A 	; hace recursivo de arrays en Ref
muli #5
addi @B+39	; fallo en este 
mov A @B+40 
mov @B+25 @B+41		; guarda id tmp
mov @B+40 A	; empieza arrays en Ref asig de: this.a
muli #1 
addi #113
mov @B+41 @A	; acaba arrays en Ref asig
L4 mov @B+1 @B+41		; guarda id j
mov #1 @B+42		; guarda entero 1
mov @B+41 A
addi @B+42	; ENTERO + ENTERO
mov A @B+43	; guardar el resultado en temporal
mov @B+43 @B+1		; j = @B+43; 
jmp L5
	; ENDWHILE
L6 mov @B+0 @B+44		; guarda id i
mov #1 @B+45		; guarda entero 1
mov @B+44 A
addi @B+45	; ENTERO + ENTERO
mov A @B+46	; guardar el resultado en temporal
mov @B+46 @B+0		; i = @B+46; 
jmp L7
	; ENDWHILE
L8 mov @B+0 @B+47		; guarda id i
mov @B+1 @B+48		; guarda id j
mov @B+47 A
addi @B+48	; ENTERO + ENTERO
mov A @B+49	; guardar el resultado en temporal
; Secuencia de retorno
mov @B+49 @B-3
mov @B-2 A
jmp @A
; DIR USED = 47
mov #0 @B-3
mov @B-2 A
jmp @A

; metodo: 'printArray'
L9 mov #0 @B+2		; guarda entero 0
mov @B+2 @B+0		; i = @B+2; 
L10 mov @B+0 @B+3		; guarda id i
mov #5 @B+4		; guarda entero 5
mov @B+3 A
lssi @B+4	; Expr relop Esimple
mov A @B+5	; guardar el resultado en temporal
	; WHILE
mov @B+5 A
jz L11	 ; if else
 
;print
mov #0 @B+6	; guarda 0 y empieza recursivo arrays de 'Ref this' this.a
mov @B+0 @B+7		; guarda id i
mov #1 @B+8		; guarda entero 1
mov @B+7 A
addi @B+8	; ENTERO + ENTERO
mov A @B+9	; guardar el resultado en temporal
mov #1 @B+10		; guarda entero 1
mov #1 @B+11		; guarda entero 1
mov @B+10 A
muli @B+11	; ENTERO * ENTERO
mov A @B+12
mov @B+9 A
subi @B+12	; ENTERO - ENTERO
mov A @B+13	; guardar el resultado en temporal
mov #6 @B+14		; guarda entero 6
mov #6 @B+15		; guarda entero 6
mov @B+14 A
divi @B+15	; ENTERO / ENTERO
mov A @B+16
mov #1 @B+17		; guarda entero 1
mov @B+16 A
muli @B+17	; ENTERO * ENTERO
mov A @B+18
mov @B+13 A
addi @B+18	; ENTERO + ENTERO
mov A @B+19	; guardar el resultado en temporal
mov #1 @B+20		; guarda entero 1
mov @B+19 A
subi @B+20	; ENTERO - ENTERO
mov A @B+21	; guardar el resultado en temporal
mov @B+6 A 	; hace recursivo de arrays en Ref
muli #5
addi @B+21	; fallo en este 
mov A @B+22 
mov #0 @B+22		; guarda 0 y empieza en Factor recursivo arrays de this.a
mov @B+22 @B+23		; guarda id this.a
muli #1 
addi #113
mov @A @B+23	;acaba array en Factor
wri @B+23	; print valor entero de temporal
wrl
mov @B+0 @B+24		; guarda id i
mov #1 @B+25		; guarda entero 1
mov @B+24 A
addi @B+25	; ENTERO + ENTERO
mov A @B+26	; guardar el resultado en temporal
mov @B+26 @B+0		; i = @B+26; 
jmp L10
	; ENDWHILE
L11 mov @B+0 @B+27		; guarda id i
; Secuencia de retorno
mov @B+27 @B-3
mov @B-2 A
jmp @A
; DIR USED = 27
mov #0 @B-3
mov @B-2 A
jmp @A

L12  ; Secuencia de llamada
mov B @B+4
mov B A
addi #5
mov A B
mvetq L13 @B-2
jmp L1
L13 mov @B-1 B
mov @B+2 @B+0		; foo = @B+2; 
; Secuencia de llamada
mov B @B+7
mov B A
addi #8
mov A B
mvetq L14 @B-2
jmp L9
L14 mov @B-1 B
mov @B+5 @B+0		; foo = @B+5; 
; Secuencia de llamada
mov B @B+10
mov B A
addi #11
mov A B
mvetq L15 @B-2
jmp L2
L15 mov @B-1 B
mov @B+8 @B+0		; foo = @B+8; 
; Secuencia de llamada
mov B @B+13
mov B A
addi #14
mov A B
mvetq L16 @B-2
jmp L9
L16 mov @B-1 B
mov @B+11 @B+0		; foo = @B+11; 
halt
