;Guarda desde: 7
;Actual empieza: 10
;Hasta: 12
;Guarda desde: 26
;Actual empieza: 29
;Hasta: 31
mov #12 B
jmp L3

; metodo: 'modifyparameters1'
L1 mov @B+0 @B+3		; guarda id a
mov #10 @B+4		; guarda entero 10
mov @B+3 A
muli @B+4	; ENTERO * ENTERO
mov A @B+5
mov @B+5 @B+0		; a = @B+5; 
mov @B+1 @B+6		; guarda id b
mov #10 @B+7		; guarda entero 10
mov @B+6 A
muli @B+7	; ENTERO * ENTERO
mov A @B+8
mov @B+8 @B+1		; b = @B+8; 
; DIR USED = 9
mov #0 @B-3
mov @B-2 A
jmp @A

; metodo: 'modifyparameters2'
L2 mov @B+0 @B+3		; guarda id c
mov #20 @B+4		; guarda entero 20
mov @B+3 A
addi @B+4	; ENTERO + ENTERO
mov A @B+5	; guardar el resultado en temporal
mov @B+5 @B+0		; c = @B+5; 
mov @B+1 @B+6		; guarda id b
mov $10.0 @B+7		; guarda real 10.0
mov @B+6 A
mulr @B+7	; REAL * REAL
mov A @B+8
mov @B+8 @B+1		; b = @B+8; 

;print
mov @B+0 @B+9		; guarda id c
wri @B+9	; print valor entero de temporal
wrl

;print
mov 11 @B+10		; guarda id this.c
wri @B+10	; print valor entero de temporal
wrl
; DIR USED = 11
mov #0 @B-3
mov @B-2 A
jmp @A

L3  
;print
mov #123 @B+3		; guarda entero 123
wri @B+3	; print valor entero de temporal
wrl
mov #55 @B+4		; guarda entero 55
mov @B+4 11		; this.c = @B+4; 
mov #44 @B+5		; guarda entero 44
mov @B+5 @B+0		; c = @B+5; 

;print
mov 11 @B+6		; guarda id this.c
wri @B+6	; print valor entero de temporal
wrl

;print
mov @B+0 @B+7		; guarda id c
wri @B+7	; print valor entero de temporal
wrl
mov @B+0 @B+13		; guarda id c
mov @B+13 @B+11	; asigna un param Par
mov 11 @B+14		; guarda id this.c
mov @B+14 @B+12	; asigna un param CPar
; Secuencia de llamada
mov B @B+10
mov B A
addi #11
mov A B
mvetq L4 @B-2
jmp L1
L4 mov @B-1 B
mov @B+8 @B+1		; foo = @B+8; 

;print
mov 11 @B+15		; guarda id this.c
wri @B+15	; print valor entero de temporal
wrl

;print
mov @B+0 @B+16		; guarda id c
wri @B+16	; print valor entero de temporal
wrl
mov #0 @B+17	; guarda 0 y empieza recursivo arrays de Ref thisthis.b
mov #0 @B+18		; guarda entero 0
mov @B+17 A 	; hace recursivo de arrays en Ref
muli #10
addi @B+18	; fallo en este 
mov A @B+19 
mov $122.2 @B+20		; guarda real 122.2
mov @B+19 A	; empieza arrays en Ref asig de: this.b
muli #1 
addi #1
mov @B+20 @A	; acaba arrays en Ref asig
mov #11 @B+21		; guarda entero 11
mov @B+21 11		; this.c = @B+21; 

;print
mov #0 @B+22	; guarda 0 y empieza recursivo arrays de Ref thisthis.b
mov #0 @B+23		; guarda entero 0
mov @B+22 A 	; hace recursivo de arrays en Ref
muli #10
addi @B+23	; fallo en este 
mov A @B+24 
mov #0 @B+24		; guarda 0 y empieza en Factor recursivo arrays de this.b
mov @B+24 @B+25		; guarda id this.b
muli #1 
addi #1
mov @A @B+25	;acaba array en Factor
wrr @B+25	; print valor real de temporal
wrl

;print
mov 11 @B+26		; guarda id this.c
wri @B+26	; print valor entero de temporal
wrl
mov 11 @B+32		; guarda id this.c
mov @B+32 @B+30	; asigna un param Par
mov #0 @B+33	; guarda 0 y empieza recursivo arrays de Ref thisthis.b
mov #0 @B+34		; guarda entero 0
mov @B+33 A 	; hace recursivo de arrays en Ref
muli #10
addi @B+34	; fallo en este 
mov A @B+35 
mov #0 @B+35		; guarda 0 y empieza en Factor recursivo arrays de this.b
mov @B+35 @B+36		; guarda id this.b
muli #1 
addi #1
mov @A @B+36	;acaba array en Factor
mov @B+36 @B+31	; asigna un param CPar
; Secuencia de llamada
mov B @B+29
mov B A
addi #30
mov A B
mvetq L5 @B-2
jmp L2
L5 mov @B-1 B
mov @B+27 @B+1		; foo = @B+27; 

;print
mov #0 @B+37	; guarda 0 y empieza recursivo arrays de Ref thisthis.b
mov #0 @B+38		; guarda entero 0
mov @B+37 A 	; hace recursivo de arrays en Ref
muli #10
addi @B+38	; fallo en este 
mov A @B+39 
mov #0 @B+39		; guarda 0 y empieza en Factor recursivo arrays de this.b
mov @B+39 @B+40		; guarda id this.b
muli #1 
addi #1
mov @A @B+40	;acaba array en Factor
wrr @B+40	; print valor real de temporal
wrl

;print
mov 11 @B+41		; guarda id this.c
wri @B+41	; print valor entero de temporal
wrl

;print
mov #321 @B+42		; guarda entero 321
wri @B+42	; print valor entero de temporal
wrl
halt
