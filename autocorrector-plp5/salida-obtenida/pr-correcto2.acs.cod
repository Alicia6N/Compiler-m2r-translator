mov #0 B
jmp L39

L39  mov #5 @B+32		; guarda entero 5
mov @B+32 @B+2		; n = @B+32; 
mov #0 @B+33		; guarda entero 0
mov @B+33 @B+0		; i = @B+33; 
L3 mov @B+0 @B+34		; guarda id i
mov @B+2 @B+35		; guarda id n
mov @B+34 A
lssi @B+35	; Expr relop Esimple
mov A @B+36	; guardar el resultado en temporal
	; WHILE
mov @B+36 A
jz L4	 ; if else
 mov #0 @B+37		; guarda entero 0
mov @B+37 @B+1		; j = @B+37; 
L1 mov @B+1 @B+38		; guarda id j
mov @B+2 @B+39		; guarda id n
mov @B+38 A
lssi @B+39	; Expr relop Esimple
mov A @B+40	; guardar el resultado en temporal
	; WHILE
mov @B+40 A
jz L2	 ; if else
 mov #0 @B+41	; guarda 0 y empieza recursivo arrays de laberinto
mov @B+0 @B+42		; guarda id i
mov @B+41 A 	; hace recursivo de arrays en Ref
muli #5
addi @B+42	; fallo en este 
mov A @B+43 
mov @B+1 @B+44		; guarda id j
mov @B+43 A 	; hace recursivo de arrays en Ref
muli #5
addi @B+44	; fallo en este 
mov A @B+45 
mov #0 @B+46		; guarda entero 0
mov @B+45 A
muli #1 
addi @B+3
mov @B+46 @A
mov @B+1 @B+47		; guarda id j
mov #1 @B+48		; guarda entero 1
mov @B+47 A
addi @B+48	; ENTERO + ENTERO
mov A @B+49	; guardar el resultado en temporal
mov @B+49 @B+1		; j = @B+49; 
jmp L1
	; ENDWHILE
L2 mov @B+0 @B+50		; guarda id i
mov #1 @B+51		; guarda entero 1
mov @B+50 A
addi @B+51	; ENTERO + ENTERO
mov A @B+52	; guardar el resultado en temporal
mov @B+52 @B+0		; i = @B+52; 
jmp L3
	; ENDWHILE
L4 mov #0 @B+53		; guarda entero 0
mov @B+53 @B+0		; i = @B+53; 
L5 mov @B+0 @B+54		; guarda id i
mov @B+2 @B+55		; guarda id n
mov @B+54 A
lssi @B+55	; Expr relop Esimple
mov A @B+56	; guardar el resultado en temporal
	; WHILE
mov @B+56 A
jz L6	 ; if else
 mov #0 @B+57	; guarda 0 y empieza recursivo arrays de laberinto
mov @B+0 @B+58		; guarda id i
mov @B+57 A 	; hace recursivo de arrays en Ref
muli #5
addi @B+58	; fallo en este 
mov A @B+59 
mov @B+0 @B+60		; guarda id i
mov @B+59 A 	; hace recursivo de arrays en Ref
muli #5
addi @B+60	; fallo en este 
mov A @B+61 
mov #1 @B+62		; guarda entero 1
mov @B+61 A
muli #1 
addi @B+3
mov @B+62 @A
mov @B+0 @B+63		; guarda id i
mov #1 @B+64		; guarda entero 1
mov @B+63 A
addi @B+64	; ENTERO + ENTERO
mov A @B+65	; guardar el resultado en temporal
mov @B+65 @B+0		; i = @B+65; 
jmp L5
	; ENDWHILE
L6 mov #0 @B+66		; guarda entero 0
mov @B+66 @B+0		; i = @B+66; 
L7 mov @B+0 @B+67		; guarda id i
mov @B+2 @B+68		; guarda id n
mov @B+67 A
lssi @B+68	; Expr relop Esimple
mov A @B+69	; guardar el resultado en temporal
	; WHILE
mov @B+69 A
jz L8	 ; if else
 mov #0 @B+70	; guarda 0 y empieza recursivo arrays de laberinto
mov @B+0 @B+71		; guarda id i
mov @B+70 A 	; hace recursivo de arrays en Ref
muli #5
addi @B+71	; fallo en este 
mov A @B+72 
mov #0 @B+73		; guarda entero 0
mov @B+72 A 	; hace recursivo de arrays en Ref
muli #5
addi @B+73	; fallo en este 
mov A @B+74 
mov #1 @B+75		; guarda entero 1
mov @B+74 A
muli #1 
addi @B+3
mov @B+75 @A
mov @B+0 @B+76		; guarda id i
mov #1 @B+77		; guarda entero 1
mov @B+76 A
addi @B+77	; ENTERO + ENTERO
mov A @B+78	; guardar el resultado en temporal
mov @B+78 @B+0		; i = @B+78; 
jmp L7
	; ENDWHILE
L8 mov #1 @B+79		; guarda entero 1
mov @B+79 @B+0		; i = @B+79; 
L9 mov @B+0 @B+80		; guarda id i
mov @B+2 @B+81		; guarda id n
mov @B+80 A
lssi @B+81	; Expr relop Esimple
mov A @B+82	; guardar el resultado en temporal
	; WHILE
mov @B+82 A
jz L10	 ; if else
 mov #0 @B+83	; guarda 0 y empieza recursivo arrays de laberinto
mov @B+2 @B+84		; guarda id n
mov #1 @B+85		; guarda entero 1
mov @B+84 A
subi @B+85	; ENTERO - ENTERO
mov A @B+86	; guardar el resultado en temporal
mov @B+83 A 	; hace recursivo de arrays en Ref
muli #5
addi @B+86	; fallo en este 
mov A @B+87 
mov @B+0 @B+88		; guarda id i
mov @B+87 A 	; hace recursivo de arrays en Ref
muli #5
addi @B+88	; fallo en este 
mov A @B+89 
mov #1 @B+90		; guarda entero 1
mov @B+89 A
muli #1 
addi @B+3
mov @B+90 @A
mov @B+0 @B+91		; guarda id i
mov #1 @B+92		; guarda entero 1
mov @B+91 A
addi @B+92	; ENTERO + ENTERO
mov A @B+93	; guardar el resultado en temporal
mov @B+93 @B+0		; i = @B+93; 
jmp L9
	; ENDWHILE
L10 mov #1 @B+94		; guarda entero 1
mov @B+94 @B+28		; lon = @B+94; 
mov #0 @B+95		; guarda entero 0
mov @B+95 @B+29		; error = @B+95; 
mov #0 @B+96		; guarda entero 0
mov @B+96 @B+30		; salir = @B+96; 
mov #0 @B+97		; guarda entero 0
mov @B+97 @B+0		; i = @B+97; 
mov #0 @B+98		; guarda entero 0
mov @B+98 @B+1		; j = @B+98; 

;print
mov @B+0 @B+99		; guarda id i
wri @B+99	; print valor entero de temporal
wrl

;print
mov @B+1 @B+100		; guarda id j
wri @B+100	; print valor entero de temporal
wrl
L22 ; Factor -> pari Expr pard
mov @B+0 @B+101		; guarda id i
mov @B+2 @B+102		; guarda id n
mov @B+101 A
lssi @B+102	; Expr relop Esimple
mov A @B+103	; guardar el resultado en temporal
; Factor -> pari Expr pard
mov @B+1 @B+104		; guarda id j
mov @B+2 @B+105		; guarda id n
mov @B+104 A
lssi @B+105	; Expr relop Esimple
mov A @B+106	; guardar el resultado en temporal
mov @B+103 A
muli @B+106	; ENTERO * ENTERO
mov A @B+107
; Factor -> pari Expr pard
mov @B+29 @B+108		; guarda id error
mov #0 @B+109		; guarda entero 0
mov @B+108 A
eqli @B+109	; Expr relop Esimple
mov A @B+110	; guardar el resultado en temporal
mov @B+107 A
muli @B+110	; ENTERO * ENTERO
mov A @B+111
; Factor -> pari Expr pard
mov @B+30 @B+112		; guarda id salir
mov #0 @B+113		; guarda entero 0
mov @B+112 A
eqli @B+113	; Expr relop Esimple
mov A @B+114	; guardar el resultado en temporal
mov @B+111 A
muli @B+114	; ENTERO * ENTERO
mov A @B+115
	; WHILE
mov @B+115 A
jz L23	 ; if else
 mov #0 @B+116	; guarda 0 y empieza recursivo arrays de laberinto
mov @B+0 @B+117		; guarda id i
mov @B+116 A 	; hace recursivo de arrays en Ref
muli #5
addi @B+117	; fallo en este 
mov A @B+118 
mov @B+1 @B+119		; guarda id j
mov @B+118 A 	; hace recursivo de arrays en Ref
muli #5
addi @B+119	; fallo en este 
mov A @B+120 
mov #0 @B+120		; guarda 0 y empieza en Factor recursivo arrays de laberinto
mov @B+120 @B+121		; guarda id laberinto
muli #1 
addi @B+3
mov @A @B+121	;acaba array en Factor
mov @B+121 A
jz L21 	 ; if 
 mov #0 @B+123		; guarda entero 0
mov @B+123 @B+121		; mov = @B+123; 
; Factor -> pari Expr pard
mov @B+0 @B+124		; guarda id i
mov @B+2 @B+125		; guarda id n
mov #1 @B+126		; guarda entero 1
mov @B+125 A
subi @B+126	; ENTERO - ENTERO
mov A @B+127	; guardar el resultado en temporal
mov @B+124 A
lssi @B+127	; Expr relop Esimple
mov A @B+128	; guardar el resultado en temporal
; Factor -> pari Expr pard
mov @B+1 @B+129		; guarda id j
mov @B+2 @B+130		; guarda id n
mov #1 @B+131		; guarda entero 1
mov @B+130 A
subi @B+131	; ENTERO - ENTERO
mov A @B+132	; guardar el resultado en temporal
mov @B+129 A
lssi @B+132	; Expr relop Esimple
mov A @B+133	; guardar el resultado en temporal
mov @B+128 A
muli @B+133	; ENTERO * ENTERO
mov A @B+134
mov @B+134 A
jz L12 	 ; if 
 mov #0 @B+135	; guarda 0 y empieza recursivo arrays de laberinto
mov @B+0 @B+136		; guarda id i
mov #1 @B+137		; guarda entero 1
mov @B+136 A
addi @B+137	; ENTERO + ENTERO
mov A @B+138	; guardar el resultado en temporal
mov @B+135 A 	; hace recursivo de arrays en Ref
muli #5
addi @B+138	; fallo en este 
mov A @B+139 
mov @B+1 @B+140		; guarda id j
mov #1 @B+141		; guarda entero 1
mov @B+140 A
addi @B+141	; ENTERO + ENTERO
mov A @B+142	; guardar el resultado en temporal
mov @B+139 A 	; hace recursivo de arrays en Ref
muli #5
addi @B+142	; fallo en este 
mov A @B+143 
mov #0 @B+143		; guarda 0 y empieza en Factor recursivo arrays de laberinto
mov @B+143 @B+144		; guarda id laberinto
muli #1 
addi @B+3
mov @A @B+144	;acaba array en Factor
mov @B+144 A
jz L11 	 ; if 
 mov @B+0 @B+145		; guarda id i
mov #1 @B+146		; guarda entero 1
mov @B+145 A
addi @B+146	; ENTERO + ENTERO
mov A @B+147	; guardar el resultado en temporal
mov @B+147 @B+0		; i = @B+147; 
mov @B+1 @B+148		; guarda id j
mov #1 @B+149		; guarda entero 1
mov @B+148 A
addi @B+149	; ENTERO + ENTERO
mov A @B+150	; guardar el resultado en temporal
mov @B+150 @B+1		; j = @B+150; 
mov @B+28 @B+151		; guarda id lon
mov #1 @B+152		; guarda entero 1
mov @B+151 A
addi @B+152	; ENTERO + ENTERO
mov A @B+153	; guardar el resultado en temporal
mov @B+153 @B+28		; lon = @B+153; 
mov #1 @B+154		; guarda entero 1
mov @B+154 @B+121		; mov = @B+154; 
L11 L12 ; Factor -> pari Expr pard
mov @B+121 @B+155		; guarda id mov
mov #0 @B+156		; guarda entero 0
mov @B+155 A
eqli @B+156	; Expr relop Esimple
mov A @B+157	; guardar el resultado en temporal
; Factor -> pari Expr pard
mov @B+0 @B+158		; guarda id i
mov @B+2 @B+159		; guarda id n
mov #1 @B+160		; guarda entero 1
mov @B+159 A
subi @B+160	; ENTERO - ENTERO
mov A @B+161	; guardar el resultado en temporal
mov @B+158 A
lssi @B+161	; Expr relop Esimple
mov A @B+162	; guardar el resultado en temporal
mov @B+157 A
muli @B+162	; ENTERO * ENTERO
mov A @B+163
mov @B+163 A
jz L14 	 ; if 
mov #0 @B+164	; guarda 0 y empieza recursivo arrays de laberinto
mov @B+0 @B+165		; guarda id i
mov #1 @B+166		; guarda entero 1
mov @B+165 A
addi @B+166	; ENTERO + ENTERO
mov A @B+167	; guardar el resultado en temporal
mov @B+164 A 	; hace recursivo de arrays en Ref
muli #5
addi @B+167	; fallo en este 
mov A @B+168 
mov @B+1 @B+169		; guarda id j
mov @B+168 A 	; hace recursivo de arrays en Ref
muli #5
addi @B+169	; fallo en este 
mov A @B+170 
mov #0 @B+170		; guarda 0 y empieza en Factor recursivo arrays de laberinto
mov @B+170 @B+171		; guarda id laberinto
muli #1 
addi @B+3
mov @A @B+171	;acaba array en Factor
mov @B+171 A
jz L13 	 ; if 
 mov @B+0 @B+172		; guarda id i
mov #1 @B+173		; guarda entero 1
mov @B+172 A
addi @B+173	; ENTERO + ENTERO
mov A @B+174	; guardar el resultado en temporal
mov @B+174 @B+0		; i = @B+174; 
mov @B+28 @B+175		; guarda id lon
mov #1 @B+176		; guarda entero 1
mov @B+175 A
addi @B+176	; ENTERO + ENTERO
mov A @B+177	; guardar el resultado en temporal
mov @B+177 @B+28		; lon = @B+177; 
mov #1 @B+178		; guarda entero 1
mov @B+178 @B+121		; mov = @B+178; 
L13 L14 ; Factor -> pari Expr pard
mov @B+121 @B+179		; guarda id mov
mov #0 @B+180		; guarda entero 0
mov @B+179 A
eqli @B+180	; Expr relop Esimple
mov A @B+181	; guardar el resultado en temporal
; Factor -> pari Expr pard
mov @B+1 @B+182		; guarda id j
mov @B+2 @B+183		; guarda id n
mov #1 @B+184		; guarda entero 1
mov @B+183 A
subi @B+184	; ENTERO - ENTERO
mov A @B+185	; guardar el resultado en temporal
mov @B+182 A
lssi @B+185	; Expr relop Esimple
mov A @B+186	; guardar el resultado en temporal
mov @B+181 A
muli @B+186	; ENTERO * ENTERO
mov A @B+187
mov @B+187 A
jz L16 	 ; if 
mov #0 @B+188	; guarda 0 y empieza recursivo arrays de laberinto
mov @B+0 @B+189		; guarda id i
mov @B+188 A 	; hace recursivo de arrays en Ref
muli #5
addi @B+189	; fallo en este 
mov A @B+190 
mov @B+1 @B+191		; guarda id j
mov #1 @B+192		; guarda entero 1
mov @B+191 A
addi @B+192	; ENTERO + ENTERO
mov A @B+193	; guardar el resultado en temporal
mov @B+190 A 	; hace recursivo de arrays en Ref
muli #5
addi @B+193	; fallo en este 
mov A @B+194 
mov #0 @B+194		; guarda 0 y empieza en Factor recursivo arrays de laberinto
mov @B+194 @B+195		; guarda id laberinto
muli #1 
addi @B+3
mov @A @B+195	;acaba array en Factor
mov @B+195 A
jz L15 	 ; if 
 mov @B+1 @B+196		; guarda id j
mov #1 @B+197		; guarda entero 1
mov @B+196 A
addi @B+197	; ENTERO + ENTERO
mov A @B+198	; guardar el resultado en temporal
mov @B+198 @B+1		; j = @B+198; 
mov @B+28 @B+199		; guarda id lon
mov #1 @B+200		; guarda entero 1
mov @B+199 A
addi @B+200	; ENTERO + ENTERO
mov A @B+201	; guardar el resultado en temporal
mov @B+201 @B+28		; lon = @B+201; 
mov #1 @B+202		; guarda entero 1
mov @B+202 @B+121		; mov = @B+202; 
L15 L16 mov @B+121 @B+203		; guarda id mov
mov #1 @B+204		; guarda entero 1
mov @B+203 A
eqli @B+204	; Expr relop Esimple
mov A @B+205	; guardar el resultado en temporal
mov @B+205 A
jz L19
 
;print
mov @B+0 @B+206		; guarda id i
wri @B+206	; print valor entero de temporal
wrl

;print
mov @B+1 @B+207		; guarda id j
wri @B+207	; print valor entero de temporal
wrl
jmp L20
L19  ; Factor -> pari Expr pard
mov @B+0 @B+208		; guarda id i
mov @B+2 @B+209		; guarda id n
mov #1 @B+210		; guarda entero 1
mov @B+209 A
subi @B+210	; ENTERO - ENTERO
mov A @B+211	; guardar el resultado en temporal
mov @B+208 A
lssi @B+211	; Expr relop Esimple
mov A @B+212	; guardar el resultado en temporal
; Factor -> pari Expr pard
mov @B+1 @B+213		; guarda id j
mov @B+2 @B+214		; guarda id n
mov #1 @B+215		; guarda entero 1
mov @B+214 A
subi @B+215	; ENTERO - ENTERO
mov A @B+216	; guardar el resultado en temporal
mov @B+213 A
lssi @B+216	; Expr relop Esimple
mov A @B+217	; guardar el resultado en temporal
mov @B+212 A
addi @B+217	; ENTERO + ENTERO
mov A @B+218	; guardar el resultado en temporal
mov @B+218 A
jz L17
mov #1 @B+219		; guarda entero 1
mov @B+219 @B+29		; error = @B+219; 
jmp L18
L17 mov #2 @B+220		; guarda entero 2
mov @B+220 @B+30		; salir = @B+220; 
L18 L20 L21 jmp L22
	; ENDWHILE
L23 mov @B+29 @B+220		; guarda id error
mov @B+220 A
jz L24 	 ; if 
mov #0 @B+221		; guarda entero 0
mov #1 @B+222		; guarda entero 1
mov @B+221 A
subi @B+222	; ENTERO - ENTERO
mov A @B+223	; guardar el resultado en temporal
mov @B+223 @B+28		; lon = @B+223; 
L24 
;print
mov @B+28 @B+224		; guarda id lon
wri @B+224	; print valor entero de temporal
wrl
mov #0 @B+225	; guarda 0 y empieza recursivo arrays de laberinto
mov #1 @B+226		; guarda entero 1
mov @B+225 A 	; hace recursivo de arrays en Ref
muli #5
addi @B+226	; fallo en este 
mov A @B+227 
mov #1 @B+228		; guarda entero 1
mov @B+227 A 	; hace recursivo de arrays en Ref
muli #5
addi @B+228	; fallo en este 
mov A @B+229 
mov #0 @B+230		; guarda entero 0
mov @B+229 A
muli #1 
addi @B+3
mov @B+230 @A
mov #1 @B+231		; guarda entero 1
mov @B+231 @B+28		; lon = @B+231; 
mov #0 @B+232		; guarda entero 0
mov @B+232 @B+29		; error = @B+232; 
mov #0 @B+233		; guarda entero 0
mov @B+233 @B+30		; salir = @B+233; 
mov #0 @B+234		; guarda entero 0
mov @B+234 @B+0		; i = @B+234; 
mov #0 @B+235		; guarda entero 0
mov @B+235 @B+1		; j = @B+235; 

;print
mov @B+0 @B+236		; guarda id i
wri @B+236	; print valor entero de temporal
wrl

;print
mov @B+1 @B+237		; guarda id j
wri @B+237	; print valor entero de temporal
wrl
L36 ; Factor -> pari Expr pard
mov @B+0 @B+238		; guarda id i
mov @B+2 @B+239		; guarda id n
mov @B+238 A
lssi @B+239	; Expr relop Esimple
mov A @B+240	; guardar el resultado en temporal
; Factor -> pari Expr pard
mov @B+1 @B+241		; guarda id j
mov @B+2 @B+242		; guarda id n
mov @B+241 A
lssi @B+242	; Expr relop Esimple
mov A @B+243	; guardar el resultado en temporal
mov @B+240 A
muli @B+243	; ENTERO * ENTERO
mov A @B+244
; Factor -> pari Expr pard
mov @B+29 @B+245		; guarda id error
mov #0 @B+246		; guarda entero 0
mov @B+245 A
eqli @B+246	; Expr relop Esimple
mov A @B+247	; guardar el resultado en temporal
mov @B+244 A
muli @B+247	; ENTERO * ENTERO
mov A @B+248
; Factor -> pari Expr pard
mov @B+30 @B+249		; guarda id salir
mov #0 @B+250		; guarda entero 0
mov @B+249 A
eqli @B+250	; Expr relop Esimple
mov A @B+251	; guardar el resultado en temporal
mov @B+248 A
muli @B+251	; ENTERO * ENTERO
mov A @B+252
	; WHILE
mov @B+252 A
jz L37	 ; if else
 mov #0 @B+253	; guarda 0 y empieza recursivo arrays de laberinto
mov @B+0 @B+254		; guarda id i
mov @B+253 A 	; hace recursivo de arrays en Ref
muli #5
addi @B+254	; fallo en este 
mov A @B+255 
mov @B+1 @B+256		; guarda id j
mov @B+255 A 	; hace recursivo de arrays en Ref
muli #5
addi @B+256	; fallo en este 
mov A @B+257 
mov #0 @B+257		; guarda 0 y empieza en Factor recursivo arrays de laberinto
mov @B+257 @B+258		; guarda id laberinto
muli #1 
addi @B+3
mov @A @B+258	;acaba array en Factor
mov @B+258 A
jz L35 	 ; if 
 mov #0 @B+260		; guarda entero 0
mov @B+260 @B+258		; mov = @B+260; 
; Factor -> pari Expr pard
mov @B+0 @B+261		; guarda id i
mov @B+2 @B+262		; guarda id n
mov #1 @B+263		; guarda entero 1
mov @B+262 A
subi @B+263	; ENTERO - ENTERO
mov A @B+264	; guardar el resultado en temporal
mov @B+261 A
lssi @B+264	; Expr relop Esimple
mov A @B+265	; guardar el resultado en temporal
; Factor -> pari Expr pard
mov @B+1 @B+266		; guarda id j
mov @B+2 @B+267		; guarda id n
mov #1 @B+268		; guarda entero 1
mov @B+267 A
subi @B+268	; ENTERO - ENTERO
mov A @B+269	; guardar el resultado en temporal
mov @B+266 A
lssi @B+269	; Expr relop Esimple
mov A @B+270	; guardar el resultado en temporal
mov @B+265 A
muli @B+270	; ENTERO * ENTERO
mov A @B+271
mov @B+271 A
jz L26 	 ; if 
 mov #0 @B+272	; guarda 0 y empieza recursivo arrays de laberinto
mov @B+0 @B+273		; guarda id i
mov #1 @B+274		; guarda entero 1
mov @B+273 A
addi @B+274	; ENTERO + ENTERO
mov A @B+275	; guardar el resultado en temporal
mov @B+272 A 	; hace recursivo de arrays en Ref
muli #5
addi @B+275	; fallo en este 
mov A @B+276 
mov @B+1 @B+277		; guarda id j
mov #1 @B+278		; guarda entero 1
mov @B+277 A
addi @B+278	; ENTERO + ENTERO
mov A @B+279	; guardar el resultado en temporal
mov @B+276 A 	; hace recursivo de arrays en Ref
muli #5
addi @B+279	; fallo en este 
mov A @B+280 
mov #0 @B+280		; guarda 0 y empieza en Factor recursivo arrays de laberinto
mov @B+280 @B+281		; guarda id laberinto
muli #1 
addi @B+3
mov @A @B+281	;acaba array en Factor
mov @B+281 A
jz L25 	 ; if 
 mov @B+0 @B+282		; guarda id i
mov #1 @B+283		; guarda entero 1
mov @B+282 A
addi @B+283	; ENTERO + ENTERO
mov A @B+284	; guardar el resultado en temporal
mov @B+284 @B+0		; i = @B+284; 
mov @B+1 @B+285		; guarda id j
mov #1 @B+286		; guarda entero 1
mov @B+285 A
addi @B+286	; ENTERO + ENTERO
mov A @B+287	; guardar el resultado en temporal
mov @B+287 @B+1		; j = @B+287; 
mov @B+28 @B+288		; guarda id lon
mov #1 @B+289		; guarda entero 1
mov @B+288 A
addi @B+289	; ENTERO + ENTERO
mov A @B+290	; guardar el resultado en temporal
mov @B+290 @B+28		; lon = @B+290; 
mov #1 @B+291		; guarda entero 1
mov @B+291 @B+258		; mov = @B+291; 
L25 L26 ; Factor -> pari Expr pard
mov @B+258 @B+292		; guarda id mov
mov #0 @B+293		; guarda entero 0
mov @B+292 A
eqli @B+293	; Expr relop Esimple
mov A @B+294	; guardar el resultado en temporal
; Factor -> pari Expr pard
mov @B+0 @B+295		; guarda id i
mov @B+2 @B+296		; guarda id n
mov #1 @B+297		; guarda entero 1
mov @B+296 A
subi @B+297	; ENTERO - ENTERO
mov A @B+298	; guardar el resultado en temporal
mov @B+295 A
lssi @B+298	; Expr relop Esimple
mov A @B+299	; guardar el resultado en temporal
mov @B+294 A
muli @B+299	; ENTERO * ENTERO
mov A @B+300
mov @B+300 A
jz L28 	 ; if 
mov #0 @B+301	; guarda 0 y empieza recursivo arrays de laberinto
mov @B+0 @B+302		; guarda id i
mov #1 @B+303		; guarda entero 1
mov @B+302 A
addi @B+303	; ENTERO + ENTERO
mov A @B+304	; guardar el resultado en temporal
mov @B+301 A 	; hace recursivo de arrays en Ref
muli #5
addi @B+304	; fallo en este 
mov A @B+305 
mov @B+1 @B+306		; guarda id j
mov @B+305 A 	; hace recursivo de arrays en Ref
muli #5
addi @B+306	; fallo en este 
mov A @B+307 
mov #0 @B+307		; guarda 0 y empieza en Factor recursivo arrays de laberinto
mov @B+307 @B+308		; guarda id laberinto
muli #1 
addi @B+3
mov @A @B+308	;acaba array en Factor
mov @B+308 A
jz L27 	 ; if 
 mov @B+0 @B+309		; guarda id i
mov #1 @B+310		; guarda entero 1
mov @B+309 A
addi @B+310	; ENTERO + ENTERO
mov A @B+311	; guardar el resultado en temporal
mov @B+311 @B+0		; i = @B+311; 
mov @B+28 @B+312		; guarda id lon
mov #1 @B+313		; guarda entero 1
mov @B+312 A
addi @B+313	; ENTERO + ENTERO
mov A @B+314	; guardar el resultado en temporal
mov @B+314 @B+28		; lon = @B+314; 
mov #1 @B+315		; guarda entero 1
mov @B+315 @B+258		; mov = @B+315; 
L27 L28 ; Factor -> pari Expr pard
mov @B+258 @B+316		; guarda id mov
mov #0 @B+317		; guarda entero 0
mov @B+316 A
eqli @B+317	; Expr relop Esimple
mov A @B+318	; guardar el resultado en temporal
; Factor -> pari Expr pard
mov @B+1 @B+319		; guarda id j
mov @B+2 @B+320		; guarda id n
mov #1 @B+321		; guarda entero 1
mov @B+320 A
subi @B+321	; ENTERO - ENTERO
mov A @B+322	; guardar el resultado en temporal
mov @B+319 A
lssi @B+322	; Expr relop Esimple
mov A @B+323	; guardar el resultado en temporal
mov @B+318 A
muli @B+323	; ENTERO * ENTERO
mov A @B+324
mov @B+324 A
jz L30 	 ; if 
mov #0 @B+325	; guarda 0 y empieza recursivo arrays de laberinto
mov @B+0 @B+326		; guarda id i
mov @B+325 A 	; hace recursivo de arrays en Ref
muli #5
addi @B+326	; fallo en este 
mov A @B+327 
mov @B+1 @B+328		; guarda id j
mov #1 @B+329		; guarda entero 1
mov @B+328 A
addi @B+329	; ENTERO + ENTERO
mov A @B+330	; guardar el resultado en temporal
mov @B+327 A 	; hace recursivo de arrays en Ref
muli #5
addi @B+330	; fallo en este 
mov A @B+331 
mov #0 @B+331		; guarda 0 y empieza en Factor recursivo arrays de laberinto
mov @B+331 @B+332		; guarda id laberinto
muli #1 
addi @B+3
mov @A @B+332	;acaba array en Factor
mov @B+332 A
jz L29 	 ; if 
 mov @B+1 @B+333		; guarda id j
mov #1 @B+334		; guarda entero 1
mov @B+333 A
addi @B+334	; ENTERO + ENTERO
mov A @B+335	; guardar el resultado en temporal
mov @B+335 @B+1		; j = @B+335; 
mov @B+28 @B+336		; guarda id lon
mov #1 @B+337		; guarda entero 1
mov @B+336 A
addi @B+337	; ENTERO + ENTERO
mov A @B+338	; guardar el resultado en temporal
mov @B+338 @B+28		; lon = @B+338; 
mov #1 @B+339		; guarda entero 1
mov @B+339 @B+258		; mov = @B+339; 
L29 L30 mov @B+258 @B+340		; guarda id mov
mov #1 @B+341		; guarda entero 1
mov @B+340 A
eqli @B+341	; Expr relop Esimple
mov A @B+342	; guardar el resultado en temporal
mov @B+342 A
jz L33
 
;print
mov @B+0 @B+343		; guarda id i
wri @B+343	; print valor entero de temporal
wrl

;print
mov @B+1 @B+344		; guarda id j
wri @B+344	; print valor entero de temporal
wrl
jmp L34
L33  ; Factor -> pari Expr pard
mov @B+0 @B+345		; guarda id i
mov @B+2 @B+346		; guarda id n
mov #1 @B+347		; guarda entero 1
mov @B+346 A
subi @B+347	; ENTERO - ENTERO
mov A @B+348	; guardar el resultado en temporal
mov @B+345 A
lssi @B+348	; Expr relop Esimple
mov A @B+349	; guardar el resultado en temporal
; Factor -> pari Expr pard
mov @B+1 @B+350		; guarda id j
mov @B+2 @B+351		; guarda id n
mov #1 @B+352		; guarda entero 1
mov @B+351 A
subi @B+352	; ENTERO - ENTERO
mov A @B+353	; guardar el resultado en temporal
mov @B+350 A
lssi @B+353	; Expr relop Esimple
mov A @B+354	; guardar el resultado en temporal
mov @B+349 A
addi @B+354	; ENTERO + ENTERO
mov A @B+355	; guardar el resultado en temporal
mov @B+355 A
jz L31
mov #1 @B+356		; guarda entero 1
mov @B+356 @B+29		; error = @B+356; 
jmp L32
L31 mov #2 @B+357		; guarda entero 2
mov @B+357 @B+30		; salir = @B+357; 
L32 L34 L35 jmp L36
	; ENDWHILE
L37 mov @B+29 @B+357		; guarda id error
mov @B+357 A
jz L38 	 ; if 
mov #0 @B+358		; guarda entero 0
mov #1 @B+359		; guarda entero 1
mov @B+358 A
subi @B+359	; ENTERO - ENTERO
mov A @B+360	; guardar el resultado en temporal
mov @B+360 @B+28		; lon = @B+360; 
L38 
;print
mov @B+28 @B+361		; guarda id lon
wri @B+361	; print valor entero de temporal
wrl
halt
