;Temporal n = @B+2
;Temporal der = @B+32
;Temporal i = @B+0
;Temporal der = @B+33
;Temporal j = @B+1
;Temporal der = @B+37
;Temporal laberinto = @B+45
;Temporal der = @B+46
;Temporal j = @B+1
;Temporal der = @B+49
;Temporal i = @B+0
;Temporal der = @B+52
;Temporal i = @B+0
;Temporal der = @B+53
;Temporal laberinto = @B+61
;Temporal der = @B+62
;Temporal i = @B+0
;Temporal der = @B+65
;Temporal i = @B+0
;Temporal der = @B+66
;Temporal laberinto = @B+74
;Temporal der = @B+75
;Temporal i = @B+0
;Temporal der = @B+78
;Temporal i = @B+0
;Temporal der = @B+79
;Temporal laberinto = @B+89
;Temporal der = @B+90
;Temporal i = @B+0
;Temporal der = @B+93
;Temporal lon = @B+28
;Temporal der = @B+94
;Temporal error = @B+29
;Temporal der = @B+95
;Temporal salir = @B+30
;Temporal der = @B+96
;Temporal i = @B+0
;Temporal der = @B+97
;Temporal j = @B+1
;Temporal der = @B+98
;Imprime temp = 
;Imprime temp = 
;Temporal mov = @B+121
;Temporal der = @B+123
;Temporal i = @B+0
;Temporal der = @B+147
;Temporal j = @B+1
;Temporal der = @B+150
;Temporal lon = @B+28
;Temporal der = @B+153
;Temporal mov = @B+121
;Temporal der = @B+154
;Temporal i = @B+0
;Temporal der = @B+174
;Temporal lon = @B+28
;Temporal der = @B+177
;Temporal mov = @B+121
;Temporal der = @B+178
;Temporal j = @B+1
;Temporal der = @B+198
;Temporal lon = @B+28
;Temporal der = @B+201
;Temporal mov = @B+121
;Temporal der = @B+202
;Imprime temp = 
;Imprime temp = 
;Temporal error = @B+29
;Temporal der = @B+219
;Temporal salir = @B+30
;Temporal der = @B+220
;Temporal lon = @B+28
;Temporal der = @B+224
;Imprime temp = 
;Temporal laberinto = @B+230
;Temporal der = @B+231
;Temporal lon = @B+28
;Temporal der = @B+232
;Temporal error = @B+29
;Temporal der = @B+233
;Temporal salir = @B+30
;Temporal der = @B+234
;Temporal i = @B+0
;Temporal der = @B+235
;Temporal j = @B+1
;Temporal der = @B+236
;Imprime temp = 
;Imprime temp = 
;Temporal mov = @B+259
;Temporal der = @B+261
;Temporal i = @B+0
;Temporal der = @B+285
;Temporal j = @B+1
;Temporal der = @B+288
;Temporal lon = @B+28
;Temporal der = @B+291
;Temporal mov = @B+259
;Temporal der = @B+292
;Temporal i = @B+0
;Temporal der = @B+312
;Temporal lon = @B+28
;Temporal der = @B+315
;Temporal mov = @B+259
;Temporal der = @B+316
;Temporal j = @B+1
;Temporal der = @B+336
;Temporal lon = @B+28
;Temporal der = @B+339
;Temporal mov = @B+259
;Temporal der = @B+340
;Imprime temp = 
;Imprime temp = 
;Temporal error = @B+29
;Temporal der = @B+357
;Temporal salir = @B+30
;Temporal der = @B+358
;Temporal lon = @B+28
;Temporal der = @B+362
;Imprime temp = 
mov #0 B
jmp L39

L39  mov #5 @B+32		; guarda entero 5
mov @B+32 @B+2		; Instr : Ref asig Expr pyc 
mov #0 @B+33		; guarda entero 0
mov @B+33 @B+0		; Instr : Ref asig Expr pyc 
L3 mov @B+0 @B+34		; guarda id i
mov @B+2 @B+35		; guarda id n
mov @B+34 A
lssi @B+35	; Expr relop Esimple
mov A @B+36	; guardar el resultado en temporal
	; WHILE
mov @B+36 A
jz L4	 ; if else
 mov #0 @B+37		; guarda entero 0
mov @B+37 @B+1		; Instr : Ref asig Expr pyc 
L1 mov @B+1 @B+38		; guarda id j
mov @B+2 @B+39		; guarda id n
mov @B+38 A
lssi @B+39	; Expr relop Esimple
mov A @B+40	; guardar el resultado en temporal
	; WHILE
mov @B+40 A
jz L2	 ; if else
 mov #0 41	; guarda 0 y empieza recursivo arrays de laberinto
mov @B+0 @B+42		; guarda id i
mov 41 A 	; hace recursivo de arrays
muli #5
addi @B+42 
mov A 43 
mov @B+1 @B+44		; guarda id j
mov @B+43 A 	; hace recursivo de arrays
muli #5
addi @B+44 
mov A 45 
mov #0 @B+46		; guarda entero 0
mov @B+45 A
muli #1 
addi #3
mov @B+46 @A
mov @B+1 @B+47		; guarda id j
mov #1 @B+48		; guarda entero 1
mov @B+47 A
addi @B+48	; ENTERO + ENTERO
mov A @B+49	; guardar el resultado en temporal
mov @B+49 @B+1		; Instr : Ref asig Expr pyc 
jmp L1
	; ENDWHILE
L2 mov @B+0 @B+50		; guarda id i
mov #1 @B+51		; guarda entero 1
mov @B+50 A
addi @B+51	; ENTERO + ENTERO
mov A @B+52	; guardar el resultado en temporal
mov @B+52 @B+0		; Instr : Ref asig Expr pyc 
jmp L3
	; ENDWHILE
L4 mov #0 @B+53		; guarda entero 0
mov @B+53 @B+0		; Instr : Ref asig Expr pyc 
L5 mov @B+0 @B+54		; guarda id i
mov @B+2 @B+55		; guarda id n
mov @B+54 A
lssi @B+55	; Expr relop Esimple
mov A @B+56	; guardar el resultado en temporal
	; WHILE
mov @B+56 A
jz L6	 ; if else
 mov #0 57	; guarda 0 y empieza recursivo arrays de laberinto
mov @B+0 @B+58		; guarda id i
mov 57 A 	; hace recursivo de arrays
muli #5
addi @B+58 
mov A 59 
mov @B+0 @B+60		; guarda id i
mov @B+59 A 	; hace recursivo de arrays
muli #5
addi @B+60 
mov A 61 
mov #1 @B+62		; guarda entero 1
mov @B+61 A
muli #1 
addi #3
mov @B+62 @A
mov @B+0 @B+63		; guarda id i
mov #1 @B+64		; guarda entero 1
mov @B+63 A
addi @B+64	; ENTERO + ENTERO
mov A @B+65	; guardar el resultado en temporal
mov @B+65 @B+0		; Instr : Ref asig Expr pyc 
jmp L5
	; ENDWHILE
L6 mov #0 @B+66		; guarda entero 0
mov @B+66 @B+0		; Instr : Ref asig Expr pyc 
L7 mov @B+0 @B+67		; guarda id i
mov @B+2 @B+68		; guarda id n
mov @B+67 A
lssi @B+68	; Expr relop Esimple
mov A @B+69	; guardar el resultado en temporal
	; WHILE
mov @B+69 A
jz L8	 ; if else
 mov #0 70	; guarda 0 y empieza recursivo arrays de laberinto
mov @B+0 @B+71		; guarda id i
mov 70 A 	; hace recursivo de arrays
muli #5
addi @B+71 
mov A 72 
mov #0 @B+73		; guarda entero 0
mov @B+72 A 	; hace recursivo de arrays
muli #5
addi @B+73 
mov A 74 
mov #1 @B+75		; guarda entero 1
mov @B+74 A
muli #1 
addi #3
mov @B+75 @A
mov @B+0 @B+76		; guarda id i
mov #1 @B+77		; guarda entero 1
mov @B+76 A
addi @B+77	; ENTERO + ENTERO
mov A @B+78	; guardar el resultado en temporal
mov @B+78 @B+0		; Instr : Ref asig Expr pyc 
jmp L7
	; ENDWHILE
L8 mov #1 @B+79		; guarda entero 1
mov @B+79 @B+0		; Instr : Ref asig Expr pyc 
L9 mov @B+0 @B+80		; guarda id i
mov @B+2 @B+81		; guarda id n
mov @B+80 A
lssi @B+81	; Expr relop Esimple
mov A @B+82	; guardar el resultado en temporal
	; WHILE
mov @B+82 A
jz L10	 ; if else
 mov #0 83	; guarda 0 y empieza recursivo arrays de laberinto
mov @B+2 @B+84		; guarda id n
mov #1 @B+85		; guarda entero 1
mov @B+84 A
subi @B+85	; ENTERO - ENTERO
mov A @B+86	; guardar el resultado en temporal
mov 83 A 	; hace recursivo de arrays
muli #5
addi @B+86 
mov A 87 
mov @B+0 @B+88		; guarda id i
mov @B+87 A 	; hace recursivo de arrays
muli #5
addi @B+88 
mov A 89 
mov #1 @B+90		; guarda entero 1
mov @B+89 A
muli #1 
addi #3
mov @B+90 @A
mov @B+0 @B+91		; guarda id i
mov #1 @B+92		; guarda entero 1
mov @B+91 A
addi @B+92	; ENTERO + ENTERO
mov A @B+93	; guardar el resultado en temporal
mov @B+93 @B+0		; Instr : Ref asig Expr pyc 
jmp L9
	; ENDWHILE
L10 mov #1 @B+94		; guarda entero 1
mov @B+94 @B+28		; Instr : Ref asig Expr pyc 
mov #0 @B+95		; guarda entero 0
mov @B+95 @B+29		; Instr : Ref asig Expr pyc 
mov #0 @B+96		; guarda entero 0
mov @B+96 @B+30		; Instr : Ref asig Expr pyc 
mov #0 @B+97		; guarda entero 0
mov @B+97 @B+0		; Instr : Ref asig Expr pyc 
mov #0 @B+98		; guarda entero 0
mov @B+98 @B+1		; Instr : Ref asig Expr pyc 
mov @B+0 @B+99		; guarda id i
wri @B+99	; print valor entero de temporal
wrl
mov @B+1 @B+100		; guarda id j
wri @B+100	; print valor entero de temporal
wrl
L22 ; Factor -> pari Expr pard
mov @B+0 @B+101		; guarda id i
mov @B+2 @B+102		; guarda id n
mov @B+101 A
lssi @B+102	; Expr relop Esimple
mov A @B+103	; guardar el resultado en temporal
; Factor -> pari Expr pard
mov @B+1 @B+104		; guarda id j
mov @B+2 @B+105		; guarda id n
mov @B+104 A
lssi @B+105	; Expr relop Esimple
mov A @B+106	; guardar el resultado en temporal
mov @B+103 A
muli @B+106	; ENTERO * ENTERO
mov A @B+107
; Factor -> pari Expr pard
mov @B+29 @B+108		; guarda id error
mov #0 @B+109		; guarda entero 0
mov @B+108 A
eqli @B+109	; Expr relop Esimple
mov A @B+110	; guardar el resultado en temporal
mov @B+107 A
muli @B+110	; ENTERO * ENTERO
mov A @B+111
; Factor -> pari Expr pard
mov @B+30 @B+112		; guarda id salir
mov #0 @B+113		; guarda entero 0
mov @B+112 A
eqli @B+113	; Expr relop Esimple
mov A @B+114	; guardar el resultado en temporal
mov @B+111 A
muli @B+114	; ENTERO * ENTERO
mov A @B+115
	; WHILE
mov @B+115 A
jz L23	 ; if else
 mov #0 116	; guarda 0 y empieza recursivo arrays de laberinto
mov @B+0 @B+117		; guarda id i
mov 116 A 	; hace recursivo de arrays
muli #5
addi @B+117 
mov A 118 
mov @B+1 @B+119		; guarda id j
mov @B+118 A 	; hace recursivo de arrays
muli #5
addi @B+119 
mov A 120 
mov #0 @B+120		; guarda 0 y empieza recursivo arrays de laberinto
mov @B+120 @B+121		; guarda id laberinto
muli #1 
addi #3
mov @A @B+121
mov @B+121 A
jz L21 	 ; if 
 mov #0 @B+123		; guarda entero 0
mov @B+123 @B+121		; Instr : Ref asig Expr pyc 
; Factor -> pari Expr pard
mov @B+0 @B+124		; guarda id i
mov @B+2 @B+125		; guarda id n
mov #1 @B+126		; guarda entero 1
mov @B+125 A
subi @B+126	; ENTERO - ENTERO
mov A @B+127	; guardar el resultado en temporal
mov @B+124 A
lssi @B+127	; Expr relop Esimple
mov A @B+128	; guardar el resultado en temporal
; Factor -> pari Expr pard
mov @B+1 @B+129		; guarda id j
mov @B+2 @B+130		; guarda id n
mov #1 @B+131		; guarda entero 1
mov @B+130 A
subi @B+131	; ENTERO - ENTERO
mov A @B+132	; guardar el resultado en temporal
mov @B+129 A
lssi @B+132	; Expr relop Esimple
mov A @B+133	; guardar el resultado en temporal
mov @B+128 A
muli @B+133	; ENTERO * ENTERO
mov A @B+134
mov @B+134 A
jz L12 	 ; if 
 mov #0 135	; guarda 0 y empieza recursivo arrays de laberinto
mov @B+0 @B+136		; guarda id i
mov #1 @B+137		; guarda entero 1
mov @B+136 A
addi @B+137	; ENTERO + ENTERO
mov A @B+138	; guardar el resultado en temporal
mov 135 A 	; hace recursivo de arrays
muli #5
addi @B+138 
mov A 139 
mov @B+1 @B+140		; guarda id j
mov #1 @B+141		; guarda entero 1
mov @B+140 A
addi @B+141	; ENTERO + ENTERO
mov A @B+142	; guardar el resultado en temporal
mov @B+139 A 	; hace recursivo de arrays
muli #5
addi @B+142 
mov A 143 
mov #0 @B+143		; guarda 0 y empieza recursivo arrays de laberinto
mov @B+143 @B+144		; guarda id laberinto
muli #1 
addi #3
mov @A @B+144
mov @B+144 A
jz L11 	 ; if 
 mov @B+0 @B+145		; guarda id i
mov #1 @B+146		; guarda entero 1
mov @B+145 A
addi @B+146	; ENTERO + ENTERO
mov A @B+147	; guardar el resultado en temporal
mov @B+147 @B+0		; Instr : Ref asig Expr pyc 
mov @B+1 @B+148		; guarda id j
mov #1 @B+149		; guarda entero 1
mov @B+148 A
addi @B+149	; ENTERO + ENTERO
mov A @B+150	; guardar el resultado en temporal
mov @B+150 @B+1		; Instr : Ref asig Expr pyc 
mov @B+28 @B+151		; guarda id lon
mov #1 @B+152		; guarda entero 1
mov @B+151 A
addi @B+152	; ENTERO + ENTERO
mov A @B+153	; guardar el resultado en temporal
mov @B+153 @B+28		; Instr : Ref asig Expr pyc 
mov #1 @B+154		; guarda entero 1
mov @B+154 @B+121		; Instr : Ref asig Expr pyc 
L11 L12 ; Factor -> pari Expr pard
mov @B+121 @B+155		; guarda id mov
mov #0 @B+156		; guarda entero 0
mov @B+155 A
eqli @B+156	; Expr relop Esimple
mov A @B+157	; guardar el resultado en temporal
; Factor -> pari Expr pard
mov @B+0 @B+158		; guarda id i
mov @B+2 @B+159		; guarda id n
mov #1 @B+160		; guarda entero 1
mov @B+159 A
subi @B+160	; ENTERO - ENTERO
mov A @B+161	; guardar el resultado en temporal
mov @B+158 A
lssi @B+161	; Expr relop Esimple
mov A @B+162	; guardar el resultado en temporal
mov @B+157 A
muli @B+162	; ENTERO * ENTERO
mov A @B+163
mov @B+163 A
jz L14 	 ; if 
mov #0 164	; guarda 0 y empieza recursivo arrays de laberinto
mov @B+0 @B+165		; guarda id i
mov #1 @B+166		; guarda entero 1
mov @B+165 A
addi @B+166	; ENTERO + ENTERO
mov A @B+167	; guardar el resultado en temporal
mov 164 A 	; hace recursivo de arrays
muli #5
addi @B+167 
mov A 168 
mov @B+1 @B+169		; guarda id j
mov @B+168 A 	; hace recursivo de arrays
muli #5
addi @B+169 
mov A 170 
mov #0 @B+170		; guarda 0 y empieza recursivo arrays de laberinto
mov @B+170 @B+171		; guarda id laberinto
muli #1 
addi #3
mov @A @B+171
mov @B+171 A
jz L13 	 ; if 
 mov @B+0 @B+172		; guarda id i
mov #1 @B+173		; guarda entero 1
mov @B+172 A
addi @B+173	; ENTERO + ENTERO
mov A @B+174	; guardar el resultado en temporal
mov @B+174 @B+0		; Instr : Ref asig Expr pyc 
mov @B+28 @B+175		; guarda id lon
mov #1 @B+176		; guarda entero 1
mov @B+175 A
addi @B+176	; ENTERO + ENTERO
mov A @B+177	; guardar el resultado en temporal
mov @B+177 @B+28		; Instr : Ref asig Expr pyc 
mov #1 @B+178		; guarda entero 1
mov @B+178 @B+121		; Instr : Ref asig Expr pyc 
L13 L14 ; Factor -> pari Expr pard
mov @B+121 @B+179		; guarda id mov
mov #0 @B+180		; guarda entero 0
mov @B+179 A
eqli @B+180	; Expr relop Esimple
mov A @B+181	; guardar el resultado en temporal
; Factor -> pari Expr pard
mov @B+1 @B+182		; guarda id j
mov @B+2 @B+183		; guarda id n
mov #1 @B+184		; guarda entero 1
mov @B+183 A
subi @B+184	; ENTERO - ENTERO
mov A @B+185	; guardar el resultado en temporal
mov @B+182 A
lssi @B+185	; Expr relop Esimple
mov A @B+186	; guardar el resultado en temporal
mov @B+181 A
muli @B+186	; ENTERO * ENTERO
mov A @B+187
mov @B+187 A
jz L16 	 ; if 
mov #0 188	; guarda 0 y empieza recursivo arrays de laberinto
mov @B+0 @B+189		; guarda id i
mov 188 A 	; hace recursivo de arrays
muli #5
addi @B+189 
mov A 190 
mov @B+1 @B+191		; guarda id j
mov #1 @B+192		; guarda entero 1
mov @B+191 A
addi @B+192	; ENTERO + ENTERO
mov A @B+193	; guardar el resultado en temporal
mov @B+190 A 	; hace recursivo de arrays
muli #5
addi @B+193 
mov A 194 
mov #0 @B+194		; guarda 0 y empieza recursivo arrays de laberinto
mov @B+194 @B+195		; guarda id laberinto
muli #1 
addi #3
mov @A @B+195
mov @B+195 A
jz L15 	 ; if 
 mov @B+1 @B+196		; guarda id j
mov #1 @B+197		; guarda entero 1
mov @B+196 A
addi @B+197	; ENTERO + ENTERO
mov A @B+198	; guardar el resultado en temporal
mov @B+198 @B+1		; Instr : Ref asig Expr pyc 
mov @B+28 @B+199		; guarda id lon
mov #1 @B+200		; guarda entero 1
mov @B+199 A
addi @B+200	; ENTERO + ENTERO
mov A @B+201	; guardar el resultado en temporal
mov @B+201 @B+28		; Instr : Ref asig Expr pyc 
mov #1 @B+202		; guarda entero 1
mov @B+202 @B+121		; Instr : Ref asig Expr pyc 
L15 L16 mov @B+121 @B+203		; guarda id mov
mov #1 @B+204		; guarda entero 1
mov @B+203 A
eqli @B+204	; Expr relop Esimple
mov A @B+205	; guardar el resultado en temporal
mov @B+205 A
jz L19
 mov @B+0 @B+206		; guarda id i
wri @B+206	; print valor entero de temporal
wrl
mov @B+1 @B+207		; guarda id j
wri @B+207	; print valor entero de temporal
wrl
jmp L20
L19  ; Factor -> pari Expr pard
mov @B+0 @B+208		; guarda id i
mov @B+2 @B+209		; guarda id n
mov #1 @B+210		; guarda entero 1
mov @B+209 A
subi @B+210	; ENTERO - ENTERO
mov A @B+211	; guardar el resultado en temporal
mov @B+208 A
lssi @B+211	; Expr relop Esimple
mov A @B+212	; guardar el resultado en temporal
; Factor -> pari Expr pard
mov @B+1 @B+213		; guarda id j
mov @B+2 @B+214		; guarda id n
mov #1 @B+215		; guarda entero 1
mov @B+214 A
subi @B+215	; ENTERO - ENTERO
mov A @B+216	; guardar el resultado en temporal
mov @B+213 A
lssi @B+216	; Expr relop Esimple
mov A @B+217	; guardar el resultado en temporal
mov @B+212 A
addi @B+217	; ENTERO + ENTERO
mov A @B+218	; guardar el resultado en temporal
mov @B+218 A
jz L17
mov #1 @B+219		; guarda entero 1
mov @B+219 @B+29		; Instr : Ref asig Expr pyc 
jmp L18
L17 mov #2 @B+220		; guarda entero 2
mov @B+220 @B+30		; Instr : Ref asig Expr pyc 
L18 L20 L21 jmp L22
	; ENDWHILE
L23 mov @B+29 @B+221		; guarda id error
mov @B+221 A
jz L24 	 ; if 
mov #0 @B+222		; guarda entero 0
mov #1 @B+223		; guarda entero 1
mov @B+222 A
subi @B+223	; ENTERO - ENTERO
mov A @B+224	; guardar el resultado en temporal
mov @B+224 @B+28		; Instr : Ref asig Expr pyc 
L24 mov @B+28 @B+225		; guarda id lon
wri @B+225	; print valor entero de temporal
wrl
mov #0 226	; guarda 0 y empieza recursivo arrays de laberinto
mov #1 @B+227		; guarda entero 1
mov 226 A 	; hace recursivo de arrays
muli #5
addi @B+227 
mov A 228 
mov #1 @B+229		; guarda entero 1
mov @B+228 A 	; hace recursivo de arrays
muli #5
addi @B+229 
mov A 230 
mov #0 @B+231		; guarda entero 0
mov @B+230 A
muli #1 
addi #3
mov @B+231 @A
mov #1 @B+232		; guarda entero 1
mov @B+232 @B+28		; Instr : Ref asig Expr pyc 
mov #0 @B+233		; guarda entero 0
mov @B+233 @B+29		; Instr : Ref asig Expr pyc 
mov #0 @B+234		; guarda entero 0
mov @B+234 @B+30		; Instr : Ref asig Expr pyc 
mov #0 @B+235		; guarda entero 0
mov @B+235 @B+0		; Instr : Ref asig Expr pyc 
mov #0 @B+236		; guarda entero 0
mov @B+236 @B+1		; Instr : Ref asig Expr pyc 
mov @B+0 @B+237		; guarda id i
wri @B+237	; print valor entero de temporal
wrl
mov @B+1 @B+238		; guarda id j
wri @B+238	; print valor entero de temporal
wrl
L36 ; Factor -> pari Expr pard
mov @B+0 @B+239		; guarda id i
mov @B+2 @B+240		; guarda id n
mov @B+239 A
lssi @B+240	; Expr relop Esimple
mov A @B+241	; guardar el resultado en temporal
; Factor -> pari Expr pard
mov @B+1 @B+242		; guarda id j
mov @B+2 @B+243		; guarda id n
mov @B+242 A
lssi @B+243	; Expr relop Esimple
mov A @B+244	; guardar el resultado en temporal
mov @B+241 A
muli @B+244	; ENTERO * ENTERO
mov A @B+245
; Factor -> pari Expr pard
mov @B+29 @B+246		; guarda id error
mov #0 @B+247		; guarda entero 0
mov @B+246 A
eqli @B+247	; Expr relop Esimple
mov A @B+248	; guardar el resultado en temporal
mov @B+245 A
muli @B+248	; ENTERO * ENTERO
mov A @B+249
; Factor -> pari Expr pard
mov @B+30 @B+250		; guarda id salir
mov #0 @B+251		; guarda entero 0
mov @B+250 A
eqli @B+251	; Expr relop Esimple
mov A @B+252	; guardar el resultado en temporal
mov @B+249 A
muli @B+252	; ENTERO * ENTERO
mov A @B+253
	; WHILE
mov @B+253 A
jz L37	 ; if else
 mov #0 254	; guarda 0 y empieza recursivo arrays de laberinto
mov @B+0 @B+255		; guarda id i
mov 254 A 	; hace recursivo de arrays
muli #5
addi @B+255 
mov A 256 
mov @B+1 @B+257		; guarda id j
mov @B+256 A 	; hace recursivo de arrays
muli #5
addi @B+257 
mov A 258 
mov #0 @B+258		; guarda 0 y empieza recursivo arrays de laberinto
mov @B+258 @B+259		; guarda id laberinto
muli #1 
addi #3
mov @A @B+259
mov @B+259 A
jz L35 	 ; if 
 mov #0 @B+261		; guarda entero 0
mov @B+261 @B+259		; Instr : Ref asig Expr pyc 
; Factor -> pari Expr pard
mov @B+0 @B+262		; guarda id i
mov @B+2 @B+263		; guarda id n
mov #1 @B+264		; guarda entero 1
mov @B+263 A
subi @B+264	; ENTERO - ENTERO
mov A @B+265	; guardar el resultado en temporal
mov @B+262 A
lssi @B+265	; Expr relop Esimple
mov A @B+266	; guardar el resultado en temporal
; Factor -> pari Expr pard
mov @B+1 @B+267		; guarda id j
mov @B+2 @B+268		; guarda id n
mov #1 @B+269		; guarda entero 1
mov @B+268 A
subi @B+269	; ENTERO - ENTERO
mov A @B+270	; guardar el resultado en temporal
mov @B+267 A
lssi @B+270	; Expr relop Esimple
mov A @B+271	; guardar el resultado en temporal
mov @B+266 A
muli @B+271	; ENTERO * ENTERO
mov A @B+272
mov @B+272 A
jz L26 	 ; if 
 mov #0 273	; guarda 0 y empieza recursivo arrays de laberinto
mov @B+0 @B+274		; guarda id i
mov #1 @B+275		; guarda entero 1
mov @B+274 A
addi @B+275	; ENTERO + ENTERO
mov A @B+276	; guardar el resultado en temporal
mov 273 A 	; hace recursivo de arrays
muli #5
addi @B+276 
mov A 277 
mov @B+1 @B+278		; guarda id j
mov #1 @B+279		; guarda entero 1
mov @B+278 A
addi @B+279	; ENTERO + ENTERO
mov A @B+280	; guardar el resultado en temporal
mov @B+277 A 	; hace recursivo de arrays
muli #5
addi @B+280 
mov A 281 
mov #0 @B+281		; guarda 0 y empieza recursivo arrays de laberinto
mov @B+281 @B+282		; guarda id laberinto
muli #1 
addi #3
mov @A @B+282
mov @B+282 A
jz L25 	 ; if 
 mov @B+0 @B+283		; guarda id i
mov #1 @B+284		; guarda entero 1
mov @B+283 A
addi @B+284	; ENTERO + ENTERO
mov A @B+285	; guardar el resultado en temporal
mov @B+285 @B+0		; Instr : Ref asig Expr pyc 
mov @B+1 @B+286		; guarda id j
mov #1 @B+287		; guarda entero 1
mov @B+286 A
addi @B+287	; ENTERO + ENTERO
mov A @B+288	; guardar el resultado en temporal
mov @B+288 @B+1		; Instr : Ref asig Expr pyc 
mov @B+28 @B+289		; guarda id lon
mov #1 @B+290		; guarda entero 1
mov @B+289 A
addi @B+290	; ENTERO + ENTERO
mov A @B+291	; guardar el resultado en temporal
mov @B+291 @B+28		; Instr : Ref asig Expr pyc 
mov #1 @B+292		; guarda entero 1
mov @B+292 @B+259		; Instr : Ref asig Expr pyc 
L25 L26 ; Factor -> pari Expr pard
mov @B+259 @B+293		; guarda id mov
mov #0 @B+294		; guarda entero 0
mov @B+293 A
eqli @B+294	; Expr relop Esimple
mov A @B+295	; guardar el resultado en temporal
; Factor -> pari Expr pard
mov @B+0 @B+296		; guarda id i
mov @B+2 @B+297		; guarda id n
mov #1 @B+298		; guarda entero 1
mov @B+297 A
subi @B+298	; ENTERO - ENTERO
mov A @B+299	; guardar el resultado en temporal
mov @B+296 A
lssi @B+299	; Expr relop Esimple
mov A @B+300	; guardar el resultado en temporal
mov @B+295 A
muli @B+300	; ENTERO * ENTERO
mov A @B+301
mov @B+301 A
jz L28 	 ; if 
mov #0 302	; guarda 0 y empieza recursivo arrays de laberinto
mov @B+0 @B+303		; guarda id i
mov #1 @B+304		; guarda entero 1
mov @B+303 A
addi @B+304	; ENTERO + ENTERO
mov A @B+305	; guardar el resultado en temporal
mov 302 A 	; hace recursivo de arrays
muli #5
addi @B+305 
mov A 306 
mov @B+1 @B+307		; guarda id j
mov @B+306 A 	; hace recursivo de arrays
muli #5
addi @B+307 
mov A 308 
mov #0 @B+308		; guarda 0 y empieza recursivo arrays de laberinto
mov @B+308 @B+309		; guarda id laberinto
muli #1 
addi #3
mov @A @B+309
mov @B+309 A
jz L27 	 ; if 
 mov @B+0 @B+310		; guarda id i
mov #1 @B+311		; guarda entero 1
mov @B+310 A
addi @B+311	; ENTERO + ENTERO
mov A @B+312	; guardar el resultado en temporal
mov @B+312 @B+0		; Instr : Ref asig Expr pyc 
mov @B+28 @B+313		; guarda id lon
mov #1 @B+314		; guarda entero 1
mov @B+313 A
addi @B+314	; ENTERO + ENTERO
mov A @B+315	; guardar el resultado en temporal
mov @B+315 @B+28		; Instr : Ref asig Expr pyc 
mov #1 @B+316		; guarda entero 1
mov @B+316 @B+259		; Instr : Ref asig Expr pyc 
L27 L28 ; Factor -> pari Expr pard
mov @B+259 @B+317		; guarda id mov
mov #0 @B+318		; guarda entero 0
mov @B+317 A
eqli @B+318	; Expr relop Esimple
mov A @B+319	; guardar el resultado en temporal
; Factor -> pari Expr pard
mov @B+1 @B+320		; guarda id j
mov @B+2 @B+321		; guarda id n
mov #1 @B+322		; guarda entero 1
mov @B+321 A
subi @B+322	; ENTERO - ENTERO
mov A @B+323	; guardar el resultado en temporal
mov @B+320 A
lssi @B+323	; Expr relop Esimple
mov A @B+324	; guardar el resultado en temporal
mov @B+319 A
muli @B+324	; ENTERO * ENTERO
mov A @B+325
mov @B+325 A
jz L30 	 ; if 
mov #0 326	; guarda 0 y empieza recursivo arrays de laberinto
mov @B+0 @B+327		; guarda id i
mov 326 A 	; hace recursivo de arrays
muli #5
addi @B+327 
mov A 328 
mov @B+1 @B+329		; guarda id j
mov #1 @B+330		; guarda entero 1
mov @B+329 A
addi @B+330	; ENTERO + ENTERO
mov A @B+331	; guardar el resultado en temporal
mov @B+328 A 	; hace recursivo de arrays
muli #5
addi @B+331 
mov A 332 
mov #0 @B+332		; guarda 0 y empieza recursivo arrays de laberinto
mov @B+332 @B+333		; guarda id laberinto
muli #1 
addi #3
mov @A @B+333
mov @B+333 A
jz L29 	 ; if 
 mov @B+1 @B+334		; guarda id j
mov #1 @B+335		; guarda entero 1
mov @B+334 A
addi @B+335	; ENTERO + ENTERO
mov A @B+336	; guardar el resultado en temporal
mov @B+336 @B+1		; Instr : Ref asig Expr pyc 
mov @B+28 @B+337		; guarda id lon
mov #1 @B+338		; guarda entero 1
mov @B+337 A
addi @B+338	; ENTERO + ENTERO
mov A @B+339	; guardar el resultado en temporal
mov @B+339 @B+28		; Instr : Ref asig Expr pyc 
mov #1 @B+340		; guarda entero 1
mov @B+340 @B+259		; Instr : Ref asig Expr pyc 
L29 L30 mov @B+259 @B+341		; guarda id mov
mov #1 @B+342		; guarda entero 1
mov @B+341 A
eqli @B+342	; Expr relop Esimple
mov A @B+343	; guardar el resultado en temporal
mov @B+343 A
jz L33
 mov @B+0 @B+344		; guarda id i
wri @B+344	; print valor entero de temporal
wrl
mov @B+1 @B+345		; guarda id j
wri @B+345	; print valor entero de temporal
wrl
jmp L34
L33  ; Factor -> pari Expr pard
mov @B+0 @B+346		; guarda id i
mov @B+2 @B+347		; guarda id n
mov #1 @B+348		; guarda entero 1
mov @B+347 A
subi @B+348	; ENTERO - ENTERO
mov A @B+349	; guardar el resultado en temporal
mov @B+346 A
lssi @B+349	; Expr relop Esimple
mov A @B+350	; guardar el resultado en temporal
; Factor -> pari Expr pard
mov @B+1 @B+351		; guarda id j
mov @B+2 @B+352		; guarda id n
mov #1 @B+353		; guarda entero 1
mov @B+352 A
subi @B+353	; ENTERO - ENTERO
mov A @B+354	; guardar el resultado en temporal
mov @B+351 A
lssi @B+354	; Expr relop Esimple
mov A @B+355	; guardar el resultado en temporal
mov @B+350 A
addi @B+355	; ENTERO + ENTERO
mov A @B+356	; guardar el resultado en temporal
mov @B+356 A
jz L31
mov #1 @B+357		; guarda entero 1
mov @B+357 @B+29		; Instr : Ref asig Expr pyc 
jmp L32
L31 mov #2 @B+358		; guarda entero 2
mov @B+358 @B+30		; Instr : Ref asig Expr pyc 
L32 L34 L35 jmp L36
	; ENDWHILE
L37 mov @B+29 @B+359		; guarda id error
mov @B+359 A
jz L38 	 ; if 
mov #0 @B+360		; guarda entero 0
mov #1 @B+361		; guarda entero 1
mov @B+360 A
subi @B+361	; ENTERO - ENTERO
mov A @B+362	; guardar el resultado en temporal
mov @B+362 @B+28		; Instr : Ref asig Expr pyc 
L38 mov @B+28 @B+363		; guarda id lon
wri @B+363	; print valor entero de temporal
wrl
halt
